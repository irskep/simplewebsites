{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Operationally Simple Web Sites","text":"<p>This site is sort of a super-blog post surveying various ways to make web sites with an eye toward simplicity and modern amenities. Today\u2019s web is full of voices shouting to use this or that hot new thing, and the loudest voices are often the least experienced, or the most motivated to sell a specific thing, regardless of its real value. So here\u2019s one guy named Steve telling you what\u2019s up.</p> <p>I wrote all this with two kinds of people in mind. One is people early in their programming journey, who see many paths but aren\u2019t sure which to take, and get a lot of advice from people with unclear trustworthiness. The other is experienced programmers who want to ship a web app once in a while and feel bewildered by the pace of change.</p> <p>Once you skim everything here, you should have a good sense of one simple web stack, and also be aware of options for how to add complexity where it makes sense to you.</p> <p>If building your web site is your full-time job, this guide is not for you. You already know everything and you don\u2019t need me.</p>"},{"location":"#what-is-operational-simpicity-mean-and-why-do-you-want-it","title":"What is operational simpicity mean, and why do you want it?","text":"<p>Operational simplicity means a few reliable parts instead of many fragile parts. It sometimes means giving up some convenience, but also has many benefits.</p>"},{"location":"#cheap-by-default","title":"Cheap by default","text":"<p>If you\u2019re not building your web site for a company, you\u2019re probably spending your own money to host it. Redundancy is expensive.</p>"},{"location":"#it-fits-in-your-head","title":"It fits in your head","text":"<p>When a whole system fits in your head, you can reason about it better when something goes wrong. A bicycle is easier to fix than a car.</p>"},{"location":"#its-less-likely-to-break","title":"It\u2019s less likely to break","text":"<p>Popular web frameworks regularly break backward compatibility, requiring manual changes to keep things working if you want to use the latest version. You can try to stay on the old version, but there\u2019s always a risk that you\u2019ll be forced to upgrade one way or another.</p> <p>When your dependencies just do less stuff, there\u2019s less stuff that can break.</p>"},{"location":"#stack-overflow-works-better","title":"Stack Overflow works better","text":"<p>When your tools have been around for a long time, lots of questions have been asked and answered.</p>"},{"location":"#here-i-made-diagrams","title":"Here, I made diagrams","text":"Conventional wisdomEasy mode"},{"location":"#surely-youd-have-to-sacrifice-ux-and-developer-productivity","title":"Surely you\u2019d have to sacrifice UX and developer productivity?","text":"<p>Not really, depending on what you\u2019re doing. The value of a JS framework is not necessarily in making you more powerful, but in helping you organize your code. It\u2019s possible to do that without bringing in a fragile build pipeline and and tens of thousands of lines of framework code.</p>"},{"location":"#why-you-should-listen-to-me","title":"Why you should listen to me","text":"<p>I\u2019ve been making web sites for over twenty years. Here\u2019s proof!</p> <p>I\u2019ve built large production web frontends from scratch in JavaScript, and small production web backends from scratch in Python. On top of being a professional software engineer, I\u2019m also an obsessive hobbyist. Most recently, I made DIYBand.net, a web site builder for bands. I also made Browserboard, which is an online whiteboard that I\u2019ve since sold. Before that, I did a bunch of wild stuff for startups that have since died. </p>"},{"location":"stacks/","title":"What\u2019s a stack?","text":"<p>I\u2019m going to restate some basic stuff in order to frame the argument.</p> <p>A \u201cstack\u201d refers to the collection of tools you use\u2014libraries, frameworks, web services, build tools\u2014to get your product to your users.</p> <p>When you stick an adjective in front of \u201cstack,\u201d it becomes more specific. Your frontend stack is the collection of JavaScript libraries and build tools you use to build your interactive interfaces. Your backend stack usually refers to the framework you chose to help you write server code, as well as your database.</p> <p>The backend\u2019s job is to send HTML, CSS, and JavaScript to the user\u2019s browser. The frontend\u2019s job is to control the web browser.</p>"},{"location":"stacks/#components-of-a-web-stack","title":"Components of a web stack","text":"<p>A web app that stores user data typically has three major parts:</p> <ol> <li>The database, where information is stored (Postgres, MySQL, SQLite\u2026)</li> <li>The web server, which responds to HTTP requests (Flask, Django, Rails, Laravel\u2026)</li> <li>The frontend, which consists of the assets executed by the user\u2019s web browser (React, Vue, Svelte, Sass\u2026)</li> </ol> <p>In addition to the stuff you write code for, there are also build tools, which turn source code into something else. In the frontend world, this typically means turning a bunch of little JavaScript files into one big JavaScript file. Often, the source files are not just in ordinary JavaScript syntax, but are actually TypeScript, JSX, TSX, Vue \u201csingle-file components,\u201d Svelte, etc.</p>"},{"location":"stacks/#stack-decay","title":"Stack decay","text":"<p>When you write code, you hope it keeps working forever. But whenever you use a tool made by somebody else, you take on two kinds of risks. First, the risk that the maintainer will change the way the tool works such that your code doesn\u2019t work as-is anymore, forcing you to update your code. And second, the risk that the tool will be abandoned, and will stop working with other things that are being updated.</p> <p>JavaScript web frameworks and build tools are almost self-parodying examples of both of these risks in action. If you choose a framework or build tool today, you can be almost certain that in three years it won\u2019t work anymore without a \u201cmigration\u201d to a new API or configuration format. For companies maintaining products with full-time engineers, this is fine, they can roll with the punches. But if you\u2019re just maintaining your site on weekends, dealing with random breakages can kill your motivation and momentum.</p>"},{"location":"stacks/#mitigating-stack-decay","title":"Mitigating stack decay","text":"<p>If you want to keep working on a web site for a long time without being occasionally distracted by backward-incompatible changes, there are two strategies you can use.</p> <ol> <li>Use old tools which still work well and have a track record of backward compatibility.</li> <li>Use tools which are easy to replace without a lot of special knowledge, or have few dependencies.</li> </ol> <p>In today\u2019s world, I\u2019m advocating for taking approach #1 on the backend, and #2 on the frontend, which mitigates risk while still allowing for a modern development workflow.</p>"},{"location":"stacks/backend/","title":"Choosing a backend stack","text":"<p>Humanity has been making web sites for over 30 years. Somehow, we keep inventing new and strange ways to write web servers, when the old ways work fine.</p>"},{"location":"stacks/backend/#make-a-multi-page-app","title":"Make a multi-page app","text":"<p>Single-page apps are a complexity trap that require you to use fragile dependencies.</p> <p>In a multi-page app, your server sends different HTML pages back in response to different URLs, but probably the same CSS and JavaScript. When you run your JS, you can look for elements on the page and add behaviors to them, up to and including replacing the whole page with JavaScript-defined UI.</p> <p>In a single-page app, your server sends the same HTML, JavaScript, and CSS no matter what URL is requested, and the JavaScript decides what to render on the page based on the browser\u2019s URL. In some ways this can feel \u201csimpler,\u201d but there are hidden costs:</p> <ol> <li>You need to use a \u201crouting\u201d library on the client. More APIs to break over time.</li> <li>Your page will probably take longer to load because you\u2019ll need to request additional data via an API after the page loads.</li> <li>Your single-page-app JS code might not be appropriate to run on your landing page without cookies, so you\u2019ll have multiple pages anyway.</li> </ol> <p>If you\u2019re confident you can make a robust SPA that works the way you want to, go for it! But in my experience, beginners seem extremely prone to getting totally lost when something goes wrong in their SPA.</p>"},{"location":"stacks/backend/#server-side-rendering-is-also-a-complexity-trap","title":"\u201cServer-side rendering\u201d is also a complexity trap","text":"<p>Lots of mainstream teaching material, including the primary React docs, steer you toward writing your web server in JavaScript and using \u201cSSR\u201d to generate HTML so that when your JS first runs, the DOM is already in the right state. Doing this adds significant complexity, and again, fragile dependencies. It also cuts you off from using languages that are better suited to writing web servers.</p>"},{"location":"stacks/backend/#use-python-and-flask-or-something-similar","title":"Use Python and Flask, or something similar","text":"<p>At this point, Flask has been used for everything, and there\u2019s a great tutorial for it.</p> <p>I don\u2019t recommend using JavaScript for your backend because the landscape changes too quickly. JavaScript web frameworks are not yet old and boring.</p>"},{"location":"stacks/backend/#what-you-give-up","title":"What you give up","text":"<p>It could be faster, which means it could be cheaper. If you want fast and cheap, use Go.</p>"},{"location":"stacks/backend/#good-alternatives","title":"Good alternatives","text":"<p>Anything that\u2019s been around for at least ten years:</p> Framework Language Laravel PHP Django Python Pyramid Python Rails Ruby Sinatra Ruby ASP.NET Core C#"},{"location":"stacks/backend/#use-sqlite","title":"Use SQLite","text":"<p>Most web sites written by hobbyists can probably run on SQLite forever.</p> <p>In practice, you can deploy SQLite in production by mounting a persistent volume on your web machine and using Litestream to replicate it to S3.</p> <p>Using SQLite isn\u2019t even necessarily a scaling tradeoff. It has the unique advantage that roundtrip time to make a query is zero milliseconds, because the database driver is running in your application process.</p> <p>Using a persistent volume typically costs very little, but also tends to not be available on the free tier of any platform-as-a-service. On Render, you\u2019ll be paying at least $7/mo for the Starter tier. On fly.io it\u2019s cheaper, more like $3/mo, but fly.io also has much worse reliablity.</p>"},{"location":"stacks/backend/#what-you-give-up_1","title":"What you give up","text":"<p>Managed database services tend to give you nice admin tools like automatic backups, which you need to figure out for yourself with SQLite. You also need to SSH into your web server in order to run database migrations when you add or remove tables or columns. (Despite these inconveniences, once you get things set up, they will keep working with no effort.)</p> <p>You\u2019ll probably also give up zero-downtime deploys, because your SQLite volume needs to be detached from the old machine before it can be attached to the new one. In my experience, each deploy to Render involves about 30 seconds of downtime.</p>"},{"location":"stacks/backend/#good-alternatives_1","title":"Good alternatives","text":"<p>Supabase does appear to have a Postgres free tier. For now.</p>"},{"location":"stacks/frontend/","title":"Choosing a frontend stack","text":"<p>\u201cUse things that are ten years old\u201d unfortunately doesn\u2019t work in the frontend world because browsers have evolved much more than HTTP has. So if you want to minimize the likelihood that one of your tools will become \u201cobsolete,\u201d your best bet is to use things that are easy to replace, or have few dependencies.</p>"},{"location":"stacks/frontend/#custom-syntax-adds-risk","title":"Custom syntax adds risk","text":"<p>The things most \u201cmodern\u201d UI frameworks have in common are (1) declarative updates and (2) custom syntax. The most common syntax is JSX, which lets you write <code>&lt;div&gt;Hello&lt;/div&gt;</code> instead of <code>h('div', {}, 'Hello')</code>. Other frameworks like Svelte and Vue have more all-consuming custom file formats which let the build tool do fancy things to your code like wrap them in hidden function calls or generate completely different code.</p> <p>The convenience of these custom syntaxes and file formats is nice, but they introduce hard dependencies on a transpilation step, where a complex program needs to run in order to turn your <code>.vue</code>, <code>.svelte</code>, or <code>.jsx</code> file into a <code>.js</code> file. And this step is almost always implemented as a plugin to another build tool such as Vite or Webpack, which means there are two dependencies that can break, and you\u2019re locked into the design decisions of the build tool you choose.</p>"},{"location":"stacks/frontend/#vanilla-js-syntax-is-viable","title":"Vanilla JS syntax is viable","text":"<p>There are frameworks which don\u2019t require special syntax, but still provide declarative updates. The biggest one is Lit, which has lots of established SaaS users, but is relatively complex. There\u2019s also the newcomer Arrow, which is a minimalist library that is very unopinionated and flexible, at the cost of making you figure out how to organize your own stuff.</p> <p>Some of the custom-syntax frameworks also support ways of calling them without custom syntax. Vue calls its plain JS form \u201crender functions.\u201d Preact and Solid give you a couple different options for writing plain JS.</p> <p>You do give up a bit of convenience, but remember, you\u2019re not only giving up convenience, you\u2019re also gaining simplicity and removing complexity from your build.</p>"},{"location":"stacks/frontend/#javascript-template-strings-are-pretty-nice-for-writing-html-these-days","title":"JavaScript template strings are pretty nice for writing HTML these days","text":"<p>The arrival of tagged templates has enabled people to bring some of the benefits of JSX back to ordinary JavaScript syntax. If you use a framework that supports something like HTM or lit-html, you can have a JSX-like experience without leaving the ES6 standard behind.</p>"},{"location":"stacks/frontend/#just-use-esbuild-and-nothing-else","title":"Just use esbuild and nothing else","text":"<p>esbuild turns a bunch of JavaScript, TypeScript, JSX, and/or TSX files into one big JavaScript file and optionally one big CSS file. It\u2019s really nice that esbuild supports JSX, because it means you can use a little bit of that syntactic magic.</p> <p>If you want to use a custom syntax, go off and learn Webpack or Vite. You\u2019re too smart for this web site. Shoo!</p>"},{"location":"stacks/frontend/#viable-web-frameworks","title":"Viable web frameworks","text":"<p>While writing all that, I did some light research into which mainstream JS frameworks can be effectively used with esbuild alone with no plugins. Here\u2019s a best-effort summary of what I found.</p> Name Plain JS by default? Slower execution when using plain JS JSX usable in esbuild? Docs for plain JS use Lit Yes n/a No n/a Arrow Yes n/a No n/a React No ? Yes React Without JSX Vue No Yes Yes Render Functions Preact Yes ? Yes Getting Started SolidJS Yes Yes No Buildless options"},{"location":"stacks/frontend/#a-note-on-sass","title":"A note on Sass","text":"<p>Sass makes it slightly more convenient to write CSS. It\u2019s not really necessary these days, but I tend to use it because it\u2019s familiar and easy to add to my workflow. The <code>sass</code> command line tool is as simple as esbuild.</p>"}]}